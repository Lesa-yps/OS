            Temp.lst				Sourcer	v7.00   13-Sep-24  10:59 pm   Page 1

; как вызывается прерывание: на контроллер прерываний приходит тик, те сигнал прерывания, контроллер формирует инт, процессор отправляет инта, контроллер 
; отправляет вектор который используется как смещение для обработчика, который начинает выполняться
; 8-ое прерывание выполняется на самом высоком уровне приоритета, остальные работы во время его выполнения запрещаются
; вопрос на защите: что запрещает сабрутина, если и так 8-ое самое приоритетное (ответ - для предотвращения повторных прерываний в течение обработки текущего прерывания)
; вызов подпрограммы sub_1 (эта SUBROUTINE запрещает маскируемые прерывания)
020C:0746  E8 0070				call	sub_1			; (07B9)
; значения регистров es, ds, ax, dx сохраняются (не писать, что в стеке! больше негде!) (сохр аппаратного контекста, выполняется в самом обработчике
; чтобы послее обработчика прерванная работа могла быть продолженна, но Ip не сохр - прикольно)
; DOS минимизированная система - поэтому сохр только те регистры, которые изменяются (особенность доса)
020C:0749  06					push	es
020C:074A  1E					push	ds
020C:074B  50					push	ax
020C:074C  52					push	dx
; ds = 40h (туда область данных биос записывается), es = 0h (адрес таблицы векторов прерываний)
; слово сегментный у адреса не пишем, так как регистры сегментные (лишнего не пишем, мы профессионалы-сантехники)
; mov - переместить (не присвоить)
; младшее слово, старшее слово пишем, а не младший/старший байт
; нет счётчика таймера! (как словосочетания) - счётчик тиков, реального времени, суточного времени
; у этого счётчика есть младшая и старшая части
020C:074D  B8 0040				mov	ax,40h
020C:0750  8E D8				mov	ds,ax
020C:0752  33 C0				xor	ax,ax			; Zero register
020C:0754  8E C0				mov	es,ax
; инкремент младшего слова счётчика реального времени по адресу DS:006Ch
020C:0756  FF 06 006C				inc	word ptr ds:[6Ch]	; (0040:006C=6Ch)
; младшее слово счётчика реального времени равно 0?
020C:075A  75 04				jnz	loc_1			; Jump if not zero
; ДА -> инкремент старшего слова счётчика реального времени по адресу DS:006Eh
020C:075C  FF 06 006E				inc	word ptr ds:[6Eh]	; (0040:006E=17h)
; проверки наступления нового дня
; вопрос: докажите что там находится реальное время!
; обратиться по нужносму адресу, получить тики, в счётчике находится кол-во тиков, которое нужно перевести (поделить на 18.2 = х секунд), а затем перевести в нормальное представление - часы-минуты-секунды
020C:0760			loc_1:
; старшее слово счётчика реального времени равно 24? (18h - это 24 часа)
020C:0760  83 3E 006E 18			cmp	word ptr ds:[6Eh],18h	; (0040:006E=17h)
020C:0765  75 15				jne	loc_2			; Jump if not equal
; ДА -> младшее слово счётчика реального времени равно 176?
020C:0767  81 3E 006C 00B0			cmp	word ptr ds:[6Ch],0B0h	; (0040:006C=6Ch)
020C:076D  75 0D				jne	loc_2			; Jump if not equal
; установление счётчиков времени в нуль при наступлении нового дня
; ДА -> ДА -> сброс счётчика реального времени
020C:076F  A3 006E				mov	word ptr ds:[6Eh],ax	; (0040:006E=17h)
020C:0772  A3 006C				mov	word ptr ds:[6Ch],ax	; (0040:006C=6Ch)
; ДА -> ДА -> установка 1 по адресу DS:0070h
020C:0775  C6 06 0070 01			mov	byte ptr ds:[70h],1	; (0040:0070=0)
020C:077A  0C 08				or	al,8
; отправление сигнала контроллеру дисковода (о вкл 2 и 3 моторов дисководов, контроллер дисковода не будет активирован, и прерывания от него не будут разрешены)
020C:077C			loc_2:
020C:077C  50					push	ax
; счётчик времени до отключения моторчика дисковода
; 2 секунды каждый тик декрем
; при обнул счётчика по известному адресу устан 0000 (нужны драйверу дисковода, чтобы ветвиться по действиям - если мотор вкл - сразу делаем действия из другого кода ос, иначе сначала разгоняем моторчик),
; затем в порт дисковода посылается сигнал об отключении моторчика
; в ос все флаги и ошибки предописаны (так что осторожно со словом флаг!)
; декремент счётчика времени до отключения моторчика дисковода по адресу DS:0040h
020C:077D  FE 0E 0040				dec	byte ptr ds:[40h]	; (0040:0040=0Eh)
; счётчик времени до отключения моторчика дисковода равен 0?
020C:0781  75 0B				jnz	loc_3			; Jump if not zero
; вызов пользовательского прерывания (так и пишем в алгоритме int 1Ch!, а в другом случае порт и адрес)
; это не чистый код, это эмуляция доса, многозадачный режим, на самом деле такого нет и это нигде не объясняется
; and здесь что делает? вопрос на защиту
; действие не такое критичное как сброс флага if - поэтому нет lock
; ДА -> сброс флага отключения моторчика дисковода по адресу DS:003Fh
020C:0783  80 26 003F F0			and	byte ptr ds:[3Fh],0F0h	; (0040:003F=0)
; ДА -> команда 0Ch в порт 3F2h - отключение моторчика дисковода
020C:0788  B0 0C				mov	al,0Ch
020C:078A  BA 03F2				mov	dx,3F2h
020C:078D  EE					out	dx,al			; port 3F2h, dsk0 contrl output
; проверяется можно ли вызвать маскируемые прерывания
020C:078E			loc_3:
020C:078E  58					pop	ax
; установлен флаг PF?
020C:078F  F7 06 0314 0004			test	word ptr ds:[314h],4	; (0040:0314=3200h)
020C:0795  75 0C				jnz	loc_4			; Jump if not zero
; ДА -> сохранение FLAGS
; до косвенного вызова, зачем? вопрос на защите
020C:0797  9F					lahf				; Load ah from flags
020C:0798  86 E0				xchg	ah,al
020C:079A  50					push	ax
; ДА -> косвенный вызов пользовательского прерывания 1Ch с помощью команды call
020C:079B  26: FF 1E 0070			call	dword ptr es:[70h]	; (0000:0070=6ADh)
020C:07A0  EB 03				jmp	short loc_5		; (07A5)
020C:07A2  90					nop
; вызов программного прерывания таймера INT 1Ch (каждые 18.2 мс)
; НЕТ -> вызов пользовательского прерывания int 1Ch 
020C:07A3			loc_4:
020C:07A3  CD 1C				int	1Ch			; Timer break (call each 18.2ms)
020C:07A5			loc_5:
; второй вызов подпрограммы sub_1 (до сброса контроллера прерывания)
020C:07A5  E8 0011				call	sub_1			; (07B9)
; команда для контроллера прерываний 8259, что прерывание обработано (в порт 20h посылка команды 20h - команда сброса контроллера прерывания
; разрешение всех прерываний
; сброс это 0 (установка это 1), сброс маски, разрешение всех прерываний)
; сброс контроллера прерываний
020C:07A8  B0 20				mov	al,20h			; ' '
020C:07AA  E6 20				out	20h,al			; port 20h, 8259-1 int command
										;  al = 20h, end of interrupt
; значения регистров es, ds, ax, dx восстанавливаются из стека
020C:07AC  5A					pop	dx
020C:07AD  58					pop	ax
020C:07AE  1F					pop	ds
020C:07AF  07					pop	es
; выход из подпрограммы-прерывания (мы не знаем что за jmp и что там, но нас интересует Iret)
; дописываем адрес и команду "... iret" (как-то так, не уверена:()
020C:07B0  E9 FE99				jmp	$-164h
020C:07B3  C4					db	0C4h
							                        ;* No entry point to code
020C:07B4  C4 0E 93E9				les	cx,dword ptr ds:[93E9h]	; (0000:93E9=275h) Load seg:offset ptr
020C:07B8  FE					db	0FEh

				;ЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯЯ
           Temp.lst				Sourcer	v7.00   13-Sep-24  10:59 pm   Page 2

				;                              SUBROUTINE
				;ЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬЬ
; запрет маскируемых прерываний
020C:07B9			sub_1		proc	near
; значения регистров ds, ax сохраняются в стеке
020C:07B9  1E					push	ds
020C:07BA  50					push	ax
; ds = 40h (область данных биос)
020C:07BB  B8 0040				mov	ax,40h
020C:07BE  8E D8				mov	ds,ax
; загрузка AH из младшего слова FLAGS
020C:07C0  9F					lahf				; Load ah from flags
; проверяется можно ли вызвать маскируемые прерывания
; установлен старший бит IOPL или флаг DF?
020C:07C1  F7 06 0314 2400			test	word ptr ds:[314h],2400h	; (0040:0314=3200h)
020C:07C7  75 0C				jnz	loc_7			; Jump if not zero
; запрет маскируемых прерываний (зануление IF)
; пишем сброс IF по адресу (через заднюю левую ногу:))
; команда lock - префиксная команда (причём видим её в живом коде 0о0), которая делает следующую за ней команду неделимой
; неделимой - значит прервать выполнение этой команды нельзя
; смотрим по википедии основную особенность команды and
; команда and выполняется - два обращения к памяти (в процессе выполнения 1 команды), команда долго выполняется, обращение к памяти - затратное действие, связь с циклом обращения к памяти
; что же делает lock перед and именно в субратине? сбрасывает IF - запрет маскируемых прерываний (прерывать выполнение этой команды нельзя - поэтому lock)
; ДА -> сброс IF по адресу DS:0314h
020C:07C9  F0> 81 26 0314 FDFF	                           lock	and	word ptr ds:[314h],0FDFFh	; (0040:0314=3200h)
020C:07D0			loc_6:
; восстановление регистров из стека
; загрузка AH в младшее слово FLAGS
020C:07D0  9E					sahf				; Store ah into flags
020C:07D1  58					pop	ax
020C:07D2  1F					pop	ds
020C:07D3  EB 03				jmp	short loc_8		; (07D8)
020C:07D5			loc_7:
; запрет маскируемых прерываний (зануление IF)
; там где cli так и пишем, не фантазируем! (cli - clear)
; НЕТ -> сброс IF командой cli
020C:07D5  FA					cli				; Disable interrupts
020C:07D6  EB F8				jmp	short loc_6		; (07D0)
; возврат из подпрограммы sub_1
020C:07D8			loc_8:
020C:07D8  C3					retn
				sub_1		endp

; как аппаратно реализуется команда лок? лок блокирует локальную шину памяти!
; те никакая другая команда обратиться к памяти не может (только та которая после лок)
; сущ физичестки локальная шина памяти, но не шина данных!
; физически 4 процессора в х86, но только один может выполнять прерывания системного таймера и он условно называется "главным"
; вопрос - почему только один? ответ - а как иначе это свести воедино?