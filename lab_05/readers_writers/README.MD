Пояснения:
Синхронизация:

Мьютекс (mutex) используется для синхронизации доступа к общей переменной val, чтобы избежать гонки данных при чтении и записи.
События can_read и can_write контролируют, когда можно читать или записывать данные. Это нужно для реализации механизма, который предотвращает одновременную запись и чтение.
Функции start_read и stop_read:

Эти функции управляют процессом чтения, синхронизируя потоки читателей с учетом наличия писателей.
Функции start_write и stop_write:

Эти функции управляют процессом записи, синхронизируя потоки писателей с учетом количества активных читателей и наличия других писателей.
Основной цикл:

В цикле каждый поток читателя и писателя выполняет свою работу несколько раз, с случайным временем простоя перед каждой операцией чтения или записи.

Некоторые позволяют указывать конкретный процесс или поток по его уникальному в рамках всей системы идентификатору.
Вот функции, с помощью которых поток может выяснить такой идентификатор — собственный или своего процесса:
DWORD GetCurrentProcessId();
DWORD GetCurrentThreadId();

Операционная система с вытесняющей многозадачностью должна использовать тот
или иной алгоритм, позволяющий ей распределять процессорное время между пото-
ками. Здесь мы рассмотрим алгоритмы, применяемые в Windows 98 и Windows 2000.
В главе 6 мы уже обсудили структуру CONTEXT, поддерживаемую в объекте ядра
«поток», и выяснили, что она отражает состояние регистров процессора на момент
последнего выполнения потока процессором. Каждые 20 мс (или около того) Windows
просматривает все существующие объекты ядра «поток» и отмечает те из них, кото-
рые могут получать процессорное время. Далее она выбирает один из таких объек-
тов и загружает в регистры процессора значения из его контекста. Эта операция на-
зывается переключением контекста (context switching). По каждому потоку Windows
ведет учет того, сколько раз он подключался к процессору. Этот показатель сообща-
ют специальные утилиты вроде Microsoft Spy++. Например, на иллюстрации ниже
показан список свойств одного из потоков. Обратите внимание, что этот поток под-
ключался к процессору 37379 раз.
Поток выполняет код и манипулирует данными в адресном пространстве своего
процесса. Примерно через 20 мс Windows сохранит значения регистров процессора
в контексте потока и приостановит его выполнение. Далее система просмотрит ос-
тальные объекты ядра «поток», подлежащие выполнению, выберет один из них, заг-
рузит его контекст в регистры процессора, и все повторится. Этот цикл операций
выбор потока, загрузка его контекста, выполнение и сохранение контекста — начи-
нается с момента запуска системы и продолжается до ее выключения.

Функция Sleep
Поток может сообщить системе не выделять ему процессорное время на определен-
ный период, вызвав:
VOID S1eep(DWORD dwMi11iseconds);
Эта функция приостанавливает поток на dwMilliseconds миллисекунд. Отметим
несколько важных моментов, связанных с функцией Sleep
- Вызывая Sleep, поток добровольно отказывается от остатка выделенного ему
кванта времени.
- Система прекращает выделять потоку процессорное время на период, пример-
но равный заданному. Все верно: если Вы укажете остановить поток на 100 мс,
приблизительно на столько он и «заснет», хотя не исключено, что его сон про-
длится на несколько секунд или даже минут больше. Вспомните, Windows не
является системой реального времени. Ваш поток может возобновиться в за-
данный момент, но это зависит от того, какая ситуация сложится в системе к
тому времени.
- Вы можете вызвать Sleep и передать в dwMilliseconds значение INFINITE, вооб-
ще запретив планировать поток. Но это не очень практично —
куда лучше корректно завершить поток, освободив его стек и объект ядра.
- Вы можете вызвать Sleep и передать в dwMilliseconds нулевое значение. Тогда
Вы откажетесь от остатка своего кванта времени и заставите систему подклю-
чить к процессору другой поток. Однако система может снова запустить Ваш
поток, если других планируемых потоков с тем же приоритетом нет.
