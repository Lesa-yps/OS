/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "pc.h"


#define SIZE_BUF 26 /*размер буфера*/

// семафоры
#define BIN_SEM 0
#define BUFF_FULL 1
#define BUFF_EMPTY 2

// операции над семафорами (уменьшение и увеличение)
#define P -1
#define V  1

/* struct sembuf {
    short sem_num; // индекс семафора
    short sem_op; // операция: увеличение, уменьшение или проверка значения
    short sem_flg; // флаги 
} */  

struct sembuf start_produce[2] = {{BUFF_EMPTY, P, 0}, {BIN_SEM, P, 0}};
struct sembuf stop_produce[2] =  {{BIN_SEM, V, 0}, {BUFF_FULL, V, 0}};
struct sembuf start_consume[2] = {{BUFF_FULL, P, 0}, {BIN_SEM, P, 0}};
struct sembuf stop_consume[2] =  {{BIN_SEM, V, 0}, {BUFF_EMPTY, V, 0}};

static char buffer[SIZE_BUF];
static int produce_index = 0;
static int consume_index = 0;
static int alpha_produce = 'a';


void *produce_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;

	// изменение значений 2-ух семафоров (start_produce)
    if (semop(semid, start_produce, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d (start_produce)", errno);
        perror(err_msg);
        exit(1);
    }
    // записываем букву в буфер и выводим её
    *(buffer + produce_index) = alpha_produce;
    printf("Producer -> %c\n", alpha_produce);
    // производители теперь пишут на следующее место и буква следующая
    if (alpha_produce == 'z')
    {
        produce_index -= SIZE_BUF;
        alpha_produce = 'a';
    }
    else
    {
        produce_index++;
        alpha_produce++;
    }
    // изменение значений 2-ух семафоров (stop_produce)
    if (semop(semid, stop_produce, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d (stop_produse)", errno);
        perror(err_msg);
        exit(1);
    }

	return (void *) &result;
}

char *consume_1_svc(void *argp, struct svc_req *rqstp)
{
	static char  result;

	// изменение значений 2-ух семафоров (start_consume)
    if (semop(semid, start_consume, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d (start_consume)", errno);
        perror(err_msg);
        exit(1);
    }
    // выводим букву из буфера
	result = *(buffer + consume_index);
    printf("Consumer -> %c\n", result);
    if (result == 'z')
        consume_index -= SIZE_BUF;
    else
        consume_index++;
    // изменение значений 2-ух семафоров (stop_consume)
    if (semop(semid, stop_consume, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d (stop_consume)", errno);
        perror(err_msg);
        exit(1);
    }

	return &result;
}
