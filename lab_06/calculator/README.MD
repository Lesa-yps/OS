Что такое скелетон?
"Скелетон" (skeleton) в контексте RPC-программирования — это заранее сгенерированный каркас программы, который:

Содержит шаблоны функций.
Обеспечивает инфраструктуру для связи между клиентом и сервером.
Требует заполнения деталей (реализации функций) разработчиком.
Это упрощает процесс разработки: программисту нужно только реализовать логику функций на стороне клиента и сервера.

Генерация файлов
Выполните следующую команду для генерации файлов из описания интерфейса calculator.x:

bash
Копировать код
rpcgen -a calculator.x
Результат генерации
Makefile.calculator
Файл для автоматической компиляции всех компонентов (клиента, сервера, вспомогательных библиотек). Его можно использовать для упрощения сборки проекта.

calculator.h
Этот файл содержит объявления функций и типов данных, описанных в calculator.x. Он включается как клиентом, так и сервером.

calculator_xdr.c
Код, ответственный за сериализацию и десериализацию нестандартных типов данных (например, структуры, массивы). Генерируется автоматически и не требует изменений.

calculator_clnt.c
Прокси для клиента. Этот файл отвечает за упаковку параметров функции в сообщение и отправку его серверу. Также не нуждается в изменении.

calculator_svc.c
Прокси для сервера. Он отвечает за обработку входящих запросов, распаковку данных, вызов реализации функции на сервере и отправку ответа клиенту. Также генерируется автоматически.

calculator_client.c
Шаблон для реализации логики клиента. Нужно дописать функциональность, например, запрос операций сложения, вычитания и т.д.

calculator_server.c
Шаблон для реализации логики сервера. В нем нужно дописать функции, описанные в файле calculator.x.

Что делать дальше?
Определите интерфейс RPC в calculator.x:
Например:

c
Копировать код
program CALCULATOR_PROG {
    version CALCULATOR_VERS {
        int ADD(intpair) = 1;
        int SUB(intpair) = 2;
    } = 1;
} = 0x23451111;

struct intpair {
    int a;
    int b;
};
Запустите команду rpcgen для генерации файлов.

Модифицируйте calculator_client.c и calculator_server.c:
Реализуйте функции, например:

В calculator_client.c добавьте код для отправки запросов на сервер.
В calculator_server.c добавьте реализацию функций ADD и SUB.
Скомпилируйте проект:
Используйте сгенерированный Makefile.calculator:

Выполнить сборку проекта с помощью Makefile.calculator, для этого необходимо в командной строке выполнить следующую команду: make -f Makefile.calculator. Для корректной сборки необходимо предварительно изменить файл Makefile.calculator, добавив флаг компиляции -I/usr/include/tirpc и флаг линковки -ltirpc.

...или компилируйте вручную:

bash
Копировать код
gcc -o calculator_client calculator_clnt.c calculator_xdr.c calculator_client.c -ltirpc
gcc -o calculator_server calculator_svc.c calculator_xdr.c calculator_server.c -ltirpc

Запустите rpcbind, сервер и клиента:

bash
Копировать код
sudo systemctl start rpcbind
./calculator_server
./calculator_client
Теперь у вас будет работающая RPC-программа!



Функция на сервере называется calculator_proc_1_svc из-за соглашений RPC и работы генератора rpcgen.

Почему функция называется именно так?
Формат имени:
Функция, сгенерированная rpcgen, следует следующему шаблону:

php
Копировать код
<имя процедуры>_<номер версии>_svc
Здесь:

calculator_proc — имя процедуры, заданное в calculator.x.
_1 — номер версии программы, определенный в CALCULATOR_VER = 1;.
_svc — суффикс, указывающий, что это серверная часть функции.
Назначение серверной функции (_svc):
Серверная функция отвечает за обработку запроса, пришедшего от клиента. Она вызывается автоматически серверной библиотекой (внутри calculator_svc.c), которая занимается распаковкой входящих данных, вызовом реализации функции и упаковкой ответа.

Что делает rpcgen:

На основе файла .x rpcgen создает "каркас" серверного кода.
Эта функция (calculator_proc_1_svc) является точкой входа, куда передаются запросы на выполнение операции.
Ваше задание — реализовать логику этой функции в файле calculator_server.c.
Как это работает?
Клиент вызывает calculator_proc_1 (обертка):
На клиентской стороне функция calculator_proc_1 автоматически отправляет запрос на сервер, упаковывая данные.

Сервер вызывает calculator_proc_1_svc:
На сервере RPC система автоматически вызывает calculator_proc_1_svc, передавая ей распакованные данные.

Реализация логики:
Вам нужно реализовать тело функции calculator_proc_1_svc в calculator_server.c. Например:

c
Копировать код
struct CALCULATOR *calculator_proc_1_svc(struct CALCULATOR *argp, struct svc_req *rqstp) {
    static struct CALCULATOR result; // Статическая переменная для возврата результата
    result = *argp; // Копируем данные клиента

    switch (argp->op) {
        case ADD:
            result.result = argp->arg1 + argp->arg2;
            break;
        case SUB:
            result.result = argp->arg1 - argp->arg2;
            break;
        case MUL:
            result.result = argp->arg1 * argp->arg2;
            break;
        case DIV:
            if (argp->arg2 != 0) {
                result.result = argp->arg1 / argp->arg2;
            } else {
                result.result = 0; // Например, 0 для деления на ноль
            }
            break;
        default:
            result.result = 0; // Неизвестная операция
    }
    return &result;
}
Итог
Суффикс _svc обозначает, что это серверная реализация процедуры. rpcgen автоматически добавляет его для различения серверной и клиентской частей программы. Ваше задание — дополнить сгенерированную функцию конкретной логикой для обработки операций.


Ошибка -lnsl: Нет такого файла или каталога означает, что ваш компилятор не может найти библиотеку libnsl. В современных дистрибутивах Linux, таких как Ubuntu, библиотека libnsl выделена в отдельный пакет, так как она больше не входит в стандартную библиотеку C (glibc).

Решение
Установите библиотеку libnsl:
В Ubuntu она доступна в следующих пакетах:

bash
Копировать код
sudo apt install libnsl-dev
Попробуйте снова выполнить сборку:

bash
Копировать код
make -f Makefile.calculator
Если ошибка сохраняется (редко):

Некоторые системы используют совместимость через TIRPC, и -lnsl может быть не нужен. Попробуйте удалить -lnsl из строки компоновки в Makefile.calculator:
makefile
Копировать код
calculator_client: $(CLIENT_OBJECTS)
    $(CC) -g -I/usr/include/tirpc -o $@ $(CLIENT_OBJECTS) -ltirpc


Запустить сервер командой ./calculator_server. Затем запустить клиент, указав в качестве параметра ip-адрес хоста (localhost в случае выполнения на ПК), выполнив команду:
Если сервер запущен на другом компьютере в сети, укажите его IP-адрес или имя хоста:
./calculator_client 127.0.0.1
или если на том же компе:
./calculator_client localhost (В другом терминале!)



*Замечание: в случае если при запуске ./calculator_server терминал печатает сообщение об ошибке вида “unable to register (TESTPROG, VERSION, udp).

необходимо перезапустить сервис rpcbind командой systemctl restart rpcbind


Заключение:

RPC являются средством взаимодействия параллельных процессов (IPC - Inter-process communication). Как известно, в самом общем случае различаются два вида взаимодействия параллельных процессов (IPC):
	1. Вызов локальных процедур (LPC – local procedure call)
	2. Вызов удаленных процедур (RPC – remote procedure call)
Вызов удаленных процедур сделан максимально подобным вызову локальных процедур. В ядре RPC не используют протокол, в чем и состоит принципиальное различие с сокетами. Действия фактически выполняются не по протоколу. Действия выполняются в сети путем связывания портов между собой.

Протоколы
Протокол — это набор правил, определяющих, как данные передаются в сети.
Примеры протоколов:

TCP (Transmission Control Protocol): надежный, с установлением соединения, гарантирует доставку данных.
UDP (User Datagram Protocol): ненадежный, без установки соединения, но более быстрый.
RPC абстрагируется от протоколов. Хотя в большинстве случаев RPC использует TCP или UDP для передачи данных, программист взаимодействует не с протоколами напрямую, а с высокоуровневыми вызовами.

Сокеты
Сокет — это программный интерфейс для работы с сетевыми соединениями.
Сокеты предоставляют универсальный механизм для отправки и получения данных по сети.

Типы сокетов:

Stream-сокеты (TCP): используются для передачи данных с гарантией доставки.
Datagram-сокеты (UDP): передают данные быстрее, но без гарантии доставки.
Свойства сокета: Сокет идентифицируется комбинацией:

IP-адреса (уникальный адрес устройства в сети),
Номера порта.
Порты
Порт — это логический идентификатор (число от 0 до 65535), который используется для различения нескольких процессов или сервисов на одном устройстве.
Примеры портов:

22: SSH
80: HTTP
443: HTTPS
Сервису или процессу выделяется порт, чтобы данные из сети могли быть направлены к правильному приложению.

Как это связано с RPC?
Без прямой работы с сокетами:
В RPC вы не создаете и не настраиваете сокеты напрямую. Вместо этого система RPC автоматически связывает клиент и сервер, используя порты и сокеты "под капотом". Вы вызываете удаленные функции, как будто они локальные.

Динамическое связывание портов:
RPC использует rpcbind (или portmap) для привязки программ (серверов) к свободным портам. Клиент запрашивает у rpcbind, на каком порту работает нужная программа, а затем устанавливает соединение с этим портом.

Пример различия с сокетами:

При работе с сокетами вам нужно явно указывать IP, порт, протокол и писать код для обработки соединений.
В RPC этого не требуется: вы описываете интерфейс (например, в calculator.x), а остальная работа (создание сокетов, связывание портов, сериализация данных) выполняется автоматически.
Пример связи:
Когда клиент вызывает функцию calculator_proc_1, происходит следующее:

Клиентская библиотека RPC связывается с rpcbind на сервере (обычно по стандартному порту 111).
rpcbind сообщает клиенту порт, на котором работает calculator_server.
Клиент создает соединение с этим портом.
Данные передаются между клиентом и сервером с использованием выбранного протокола (TCP или UDP).
Таким образом, RPC абстрагирует сложность работы с сокетами, портами и протоколами, предоставляя простой интерфейс для вызова удаленных процедур.




Задание на лабораторную работу

Необходимо реализовать алгоритм Лампорта “Булочная”: процессы клиенты обращаются к серверу для получения номера. Сервер каждому приходящему клиенту выдает номер – максимальный из выданных + единица.