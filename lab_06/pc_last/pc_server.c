/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <pthread.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "pc.h"


// операции над семафорами (уменьшение и увеличение)
#define P -1
#define V  1

// семафоры
#define BIN_SEM 0
#define BUFF_FULL 1
#define BUFF_EMPTY 2

#define SIZE_BUF 1024

/* struct sembuf {
    short sem_num; // индекс семафора
    short sem_op; // операция: увеличение, уменьшение или проверка значения
    short sem_flg; // флаги 
} */  

struct sembuf start_produce[2] = {{BUFF_EMPTY, P, 0}, {BIN_SEM, P, 0}};
struct sembuf stop_produce[2] =  {{BIN_SEM, V, 0}, {BUFF_FULL, V, 0}};
struct sembuf start_consume[2] = {{BUFF_FULL, P, 0}, {BIN_SEM, P, 0}};
struct sembuf stop_consume[2] =  {{BIN_SEM, V, 0}, {BUFF_EMPTY, V, 0}};

struct buff_addr
{
    char buffer[SIZE_BUF];
    char *addr_prod;
    char *addr_cons;
    char letter;
};

struct buff_addr addr;
int first_call = 1;
int semid;

void signal_handler(int signal_num)
{
    int rc = 0;
    if (semctl(semid, IPC_RMID, 0) == -1)
    {
        perror("Error semctl:");
        rc = 1;
    }
    exit(rc);
}


char producer(struct buff_addr *addr)
{
    // изменение значений 2-ух семафоров (start_produce)
    if (semop(semid, start_produce, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop  errno %d", errno);
        perror(err_msg);
        exit(1);
    }

	// записываем букву в буфер и выводим её
    *(addr->addr_prod) = addr->letter;
    char produced = *(addr->addr_prod);
    printf("Producer -> %c\n", produced);

    if (produced == 'z')
        addr->letter = 'a';
    else
        (addr->letter)++;
    (addr->addr_prod)++;

    // изменение значений 2-ух семафоров (stop_produce)
    if (semop(semid, stop_produce, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d", errno);
        perror(err_msg);
        exit(1);
    }

    return produced;
}

char consumer(struct buff_addr *addr)
{
    // изменение значений 2-ух семафоров (start_consume)
    if (semop(semid, start_consume, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d", errno);
        perror(err_msg);
        exit(1);
    }

    // выводим букву из буфера
    char consumed = *(addr->addr_cons);
    (addr->addr_cons)++;
    printf("Consumer -> %c\n", consumed);

	// изменение значений 2-ух семафоров (stop_consume)
    if (semop(semid, stop_consume, 2) == -1)
    {
        char err_msg[100];
        sprintf(err_msg, "Error: semop errno %d", errno);
        perror(err_msg);
        exit(1);
    }
    return consumed;
}


bool_t
service_1_svc(int *argp, char *result, struct svc_req *rqstp)
{
	// Проверка аргумента
    if (!argp || !result)
        return FALSE;

    setbuf(stdout, 0);
    // Устанавливаем обработчик сигнала
	// SIGINT - сигнал (Ctrl-C).
	if (signal(SIGINT, signal_handler) == SIG_ERR)
    {
    	perror("Can't signal:\n");
    	exit(EXIT_FAILURE);
    }
    char res_letter;

    if (first_call)
    {
        // Инициализация семафоров
        key_t semkey = ftok("file.txt", 4);
        if (semkey == (key_t)-1) {
            perror("Error: ftok\n");
            exit(1);
        }

        semid = semget(semkey, 3, IPC_CREAT | 0666);
        if (semid == -1) {
            perror("Error: semget\n");
            exit(1);
        }
        // Идентификация 3-ёх семафоров
        // Функция semctl() позволяет изменять управляющие параметры набора семафоров
        int rc_bin_sem = semctl(semid, BIN_SEM, SETVAL, 1);
        int rc_buff_empty = semctl(semid, BUFF_EMPTY, SETVAL, SIZE_BUF);
        int rc_buff_full = semctl(semid, BUFF_FULL, SETVAL, 0);
        if (rc_bin_sem == -1)
        {
            perror("Error: semctl (BIN_SEM).\n");
            exit(1);
        }
        if (rc_buff_empty == -1)
        {
            perror("Error: semctl (BUFF_EMPTY).\n");
            exit(1);
        }
        if  (rc_buff_full == -1)
        {
            perror("Error: semctl (BUFF_FULL).\n");
            exit(1);
        }

        addr.addr_prod = addr.buffer;
        addr.addr_cons = addr.buffer;
        addr.letter = 'a';

        first_call = 0;
    }

    if (*argp == 0) {
        res_letter = producer(&addr);
        *result = res_letter;
    } else if (*argp == 1) {
        res_letter = *result = consumer(&addr);
        *result = res_letter;
    } else {
        return FALSE; // Неверный аргумент
    }

    return TRUE;
}

int
pc_prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	return 1;
}
